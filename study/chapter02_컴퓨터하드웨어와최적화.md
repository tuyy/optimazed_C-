## 컴퓨터 하드웨어와 최적화
### 기본 컴퓨터 프로그램 실행 흐름
* 모든 컴퓨터는 메모리에 저장된 명령을 실행하는 방법으로 작동한다.
* 이때 메모리에 저장되어 있는 데이터에 명령을 실행한다.
* 메모리는 각각 몇 비트의 여러 작은 워드(word)로 나뉘며, 몇 가지 특별한 메모리 워드를 레지스터라고 하는데, 이들은 기계어에서 직접 그 이름을 사용한다. 대부분의 메모리 워드는 address로 지정된다.
* 각 컴퓨터의 특정 레지스터에는 실행할 다음 명령의 주소가 들어 있다.
* 실행 주소는 다음에 읽을 단어를 가리키는 손가락과 같다. (Program Counter)
* 실행 유닛(프로세서, 코어, CPU, 컴퓨터 등으로 불리는)은 메모리에서 명령의 흐름을 판독하고 작동한다.
* 각 명령은 무슨 데이터를 읽을지, 데이터를 처리할지, 무슨 결과를 메모리에 쓸지를 실행유닛에게 알려준다.

### C++은 컴퓨터의 거짓말을 믿습니다
#### 위와 같은 단순한 모델 아래 C++의 숨겨진 진실(?)
* C++ 프로그램은 '마치' 명령문을 순서대로 실행하는 것처럼 작동하기만하면 된다.
* C++11 부터는 단일 실행 주소만 있다고 믿지 않는다. (표준 Thread 기능 제공)
* 특정 메모리 주소는 일반 메모리가 아닌 장치 레지스터가 될 수 있다. 이 주소의 값은 동일한 스레드가 두 번 연속해서 읽는 사이에 변할 수 있으며 이는 하드웨어에 일부 변경이 있었음을 나타낸다. C++에서는 이러한 위치를 volatile로 나타낸다.
* C++11은 std::atomic<>이라는 마법 주문을 제공한다. std::atomic<>은 메모리를 잠시 동안 마치 단순한 선형 바이트 저장소인 것처럼 작동하게 만들고, 멀티스레드 실행, 멀티 레이어 메모리 캐시 등으로 현대 마이크로프로세서의 모든 복잡성을 제거하려한다.
* 운영체제 또한 사용자에게 거짓말한다. 컴퓨터에서 단독으로 프로그램이 실행되고, 물리메모리는 무한하며, 프로그램의 스레드를 실행할 수 있는 프로세서가 무한으로 있다는 것이다.
* 이는 성능 측정을 복잡하게 만들 수 있지만, 프로그램을 느리게 실행할 때를 제외하고는 큰 영향을 미치지 않는다.

### 컴퓨터의 진실
* 최적화에서 중요한 점은 실제 컴퓨터의 메모리 하드웨어는 명령 실행 속도보다 매우 느리고 메모리는 실제로 바이트 단위로 접근되지 않으며 동일한 셀로 구성된 간단한 선형 배열이 아니며 유한한 용량을 가진다는 것이다.

#### 메모리는 느립니다
* 메인 메모리는 마이크로프로세서에 있는 게이트와 레지스터보다 매우 느리다.(수백 ~ 수천배)
* 메모리 접근 비용은 프로세서의 다른 비용들을 압도한다.

#### 메모리는 워드 단위로 접근합니다
* 데스크톱급 프로세서는 한번에 64바이트를 가져온다.
* C++ int, double, 포인터처럼 여러 바이트를 사져올때 실제 두 워드에 걸쳐 있을 수 있다. 이를 정렬되지 않은 메모리 접근 이라고 한다.
* 정렬되지 않은 접근은 모든 바이트가 같은 워드에 있을 떄보다 시간이 2배로 걸린다.

#### 메모리마다 접근 속도가 다릅니다
* 프로세서와 매우 가까운 곳에 속도가 빠른 일종의 캐시 메모리가 있다.
* 데스크톱 프로세서는 L1/L2/L3 캐시 메모리를 가지고 있으며 각 레벨은 아래 단계보다 약 10배 빠르다.
* L1/L2/L3 캐시, 메인메모리, 디스크상 가상 메모리 페이지 중 어디에 있는지에 따라 메모리에 접근하는 데 드는 시간을 5단계로 나눌 수 있다.
* 실행 유닛에서 캐시에 없는 데이터를 가져와야 하는 경우에 현재 캐시에 있는 데이터 중 일부를 삭제해야하며 보통 가장 오래전에 사용된 데이터를 삭제한다.
* 캐시에 없는 데이터를 1바이트만 읽어도 근처에 있는 바이트가 함께 캐싱된다. (공간 지역성)
* C++ 반복문 코드 블록은 반복무을 구성하는 명령어들이 자주 사용되며 서로 근처에 있기때문에 더 빠르게 실행되고 캐시에 남아 있을 가능성이 높다.
* 반면 함수 호출 코드 블록이나 여기저기 돌아다니며 작업을 수행하는 if문은 코드의 각 부분이 적게 사용되고 데이터가 서로 근처에 있지 않기 때문에 더 느리게 실행될 가능성이 높다.
* 벡터처럼 연속된 공간으로 구성된 자료구조는 캐시상에서 연속된 공간에 존재하며 캐시 공간을 차지하는 개수가 적기 떄문에 포인터로 연결된 자료구조보다 접근 속도가 빠르다.

#### 워드를 저장하는 방법에는 빅 엔디언과 리틀 엔디언이 있습니다
* "첫 번째 바이트(주소값이 가장 작은 바이트)를 int의 최상위 비트(MSB)로 정할 것인가, 최하위 비트(LSB)로 정할 것인가?"
```
value: 0x01234567
address: 1000 ~ 1003번지

빅엔디언 : 최상위 비트를 먼저 저장 
1000: 0x67
~
1003: 0x01

리틀엔디언 : 최하위 비트를 먼저 저장
1000: 0x01
~
1003: 0x67
```
* 둘 중 어느 것을 선택해도 상관 없지만, 데이터를 디스크에 기록하거나 네트워크 상으로 전송할때 동기화를 맞추지않으면 문제가 있을 수 있어 조심해야한다.

#### 메모리는 한정된 자원입니다
* OS는 무한한 메모리라는 환상을 유지하기 위해 캐시 메모리 같은 휘발성 물리 메모리를 사용할 수 있으며 크기에 맞지 않는 데이터를 디스크의 파일로 저장하기도 한다. 이를 가상 메모리라고 한다.
* 그러나 까상 메모리는 디스크에서 메모리 블록을 검색하는 데 수십 밀리초가 걸린다.
* 데스크톱은 기가 단위의 메인 메모리를 가질 수 있지만, 캐시의 크기는 1MB정도 된다.
* 실제 필요한 데이터가 물리 메모리에 없을 경우 이를 가상 메모리에서 가져오는데, 이를 페이지 폴트 라고 한다. 페이지 스래싱은 CPU가 실제 수행해야 할 작업보다 페이지 폴트를 처리하는 데 더 많은 시간을 할애하는 문제를 뜻한다.

#### 명령 실행은 느립니다
* 메모리에 접근하는 비용이 계산 비용을 압도한다는 점은 최적화의 중요성을 보여주는 대목이다.
* 명령 A가 명령 B에 필요한 값을 계산한다고 가정하면, 명령 B는 명령 A가 결과를 생성할 때까지 값을 계산할 수 없다. 이 때문에 파이프라인 스톨이 발생하며 두 명령의 실행이 완적히 겹치지 않기 때문에 명령의 실행이 잠시 중단된다.

#### 컴퓨터는 의사 결정을 잘 하지 못합니다
* 실행의 흐름을 변경하는 명령은 느리다. 점프나 함수 같은 명령어들은 실행 주소를 임의의 새값으로 변경하여 점프 명령을 처리하는 중 실행 주소가 갱신될 떄까지 메모리에서 잠시 동안 읽을 수 없으며 파이프라인에 놓일 수도 없다. 즉 이동안엔 파이프라인은 스톨된다.
* 계산이 의사 결정보다 빠르다는 점은 최적화의 중요성을 보여준다.

#### 프로그램 실행에는 여러 스트림이 있습니다
* 모든 프로그램은 컴퓨터 자원을 차지하려고 다른 프로그램과 경쟁한다.
* Context Switching 비용은 상당히 높다. 왜냐하면 일시 중단할 스레드의 프로세서 레지스터를 저장하고 실행을 다시 시작할 스레드의 저장된 레지스터를 불러오기 때문이다.
* 새 스레드가 다시 실행되어도 해당 데이터가 캐시에 저장되지 않을 수 있으므로 새 컨텍스트를 캐시로 불러오는 동안 초기에 실행 속도가 잠시 느려질 수 있다.
* 스레드 간 공유하지 않는 데이터에 접근하는 속도보다 스레드 간 공유하는 데이터에 접근하는 속도가 훨씬 느리다.

#### 운영체제 기능을 호출하는 비용은 높습니다
* 시스템 호출 비용이 한 프로그램의 단일 스레드 내에서 함수를 호출하는 것보다 수백배 더 크다는 점은 최적화의 중요성을 보여준다.

### C++도 거짓말을 합니다
* C++에서 가장 큰 거짓말은 사용자가 실행하는 컴퓨터가 간단하고 일관된 구조를 가졌다는 말이다. C++은 이 거짓말을 믿는 척하는 대가로 사용자가 마이크로프로세서 장치의 모든 세부 사항을 몰라도 프로그래밍할 수 있게 해준다.

#### 문장의 비용이 똑같이 높지는 않습니다
* 어떤 문장은 많은 양의 계산을 숨기며 문장의 형태만으로는 비용이 얼마나 드는지 알 수 없다.
```C++
// BigInstance의 생성자 멤버 함수를 호출한다는 건데 여기에 임의의 복잡한 계산이 숨겨질 수 있다.
BigInstance i = OtherObject;
```
#### 문장은 순서대로 실행되지 않습니다
* 동기화 코드는 동시에 실행 가능한 스레드가 데이터를 공유할 때 얻을 수 있는 동시성을 줄인다.
